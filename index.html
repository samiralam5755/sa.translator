<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SA.Translator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        :root {
            --font-family-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            
            --primary-hue: 210; 
            --primary-saturation: 80%;
            --primary-lightness: 55%;

            --primary-color: hsl(var(--primary-hue), var(--primary-saturation), var(--primary-lightness));
            --primary-color-dark: hsl(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) - 10%));
            --primary-color-light: hsl(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) + 25%));
            --primary-color-translucent: hsla(var(--primary-hue), var(--primary-saturation), var(--primary-lightness), 0.1);


            --secondary-color: #6c757d; 
            --secondary-color-dark: #545b62;

            --text-color: #333;
            --text-color-light: #555;
            --bg-color: #f7f9fc; 
            --surface-color: #ffffff;
            --border-color: #e0e0e0; 
            --border-color-focus: var(--primary-color);

            --success-color: #28a745;
            --danger-color: #e74c3c; 
            --danger-color-dark: #c0392b;

            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            
            --border-radius-sm: 0.25rem;
            --border-radius-md: 0.375rem;
            --border-radius-lg: 0.5rem;

            --transition-speed: 0.2s;
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-sans);
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            background-color: var(--surface-color);
            padding: 25px 30px;
            border-radius: var(--border-radius-lg);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 950px;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 25px;
            font-weight: 600;
            font-size: 2.25em;
        }
        h1 .fas {
            margin-right: 10px;
            font-size: 0.9em;
        }

        .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
            flex-wrap: wrap;
        }

        .lang-select-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-grow: 1;
        }

        select, button, input[type="file"] {
            padding: 0.65em 0.9em;
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
            font-size: 0.95em;
            font-family: inherit;
            transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }
        select:focus, textarea:focus {
            border-color: var(--border-color-focus);
            box-shadow: 0 0 0 3px hsla(var(--primary-hue), var(--primary-saturation), var(--primary-lightness), 0.25);
            outline: none;
        }

        select {
            flex-grow: 1;
            min-width: 180px;
            background-color: var(--surface-color); 
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            font-weight: 500;
            border: 1px solid transparent; 
            transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease;
        }
        button:hover {
            background-color: var(--primary-color-dark);
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0px);
        }

        button .fas, button .far {
            margin-right: 6px;
        }

        button.secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        button.secondary:hover {
            background-color: var(--secondary-color-dark);
        }
        button.danger {
            background-color: var(--danger-color);
            color: white;
        }
        button.danger:hover {
            background-color: var(--danger-color-dark);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            opacity: 0.7;
        }

        .text-area-container {
            position: relative;
            margin-bottom: 20px;
        }

        textarea {
            width: 100%; 
            min-height: 160px;
            padding: 12px;
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
            font-size: 1em;
            resize: vertical;
            font-family: inherit;
            line-height: 1.5;
        }

        .char-count {
            font-size: 0.85em;
            color: var(--text-color-light);
            text-align: right;
            margin-top: 6px;
        }

        .detected-lang-feedback {
            font-style: italic;
            color: var(--success-color);
            margin-left: 10px;
            font-size: 0.85em;
            padding: 5px 8px;
            background-color: hsla(120, 60%, 95%, 1);
            border-radius: var(--border-radius-sm);
        }

        .input-actions, .output-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .history-favorites-section {
            margin-top: 35px;
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 25px;
        }

        .history-column, .favorites-column {
            background-color: var(--bg-color); 
            padding: 20px;
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }
        
        .history-column h3, .favorites-column h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
        }
        .history-column h3 button, .favorites-column h3 button {
            font-size: 0.8em; 
            padding: 0.4em 0.6em;
        }

        .history-item, .favorite-item {
            background-color: var(--surface-color);
            padding: 12px 15px;
            margin-bottom: 12px;
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 0.9em;
            transition: box-shadow var(--transition-speed) ease, transform var(--transition-speed) ease;
            box-shadow: var(--shadow-sm);
        }
        .history-item:hover, .favorite-item:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
            border-left: 3px solid var(--primary-color);
            padding-left: calc(15px - 3px); 
        }
        .history-item p, .favorite-item p {
            margin: 6px 0;
        }
        .history-item .meta, .favorite-item .meta {
            font-size: 0.8em;
            color: var(--text-color-light);
        }
        .history-item .actions, .favorite-item .actions {
            text-align: right;
            margin-top: 8px;
        }
        .history-item .actions button, .favorite-item .actions button {
            padding: 4px 8px;
            font-size: 0.85em;
            background-color: transparent;
            color: var(--secondary-color);
            border: none;
        }
         .history-item .actions button:hover, .favorite-item .actions button:hover {
            color: var(--danger-color);
            background-color: hsla(var(--primary-hue), 0%, 0%, 0.05);
        }


        .loading-feedback {
            text-align: center;
            padding: 15px;
            color: var(--text-color-light);
            font-size: 0.9em;
        }
        .loading-feedback.active {
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        .loading-feedback:not(.active) {
            display: none;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid var(--primary-color-translucent);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #micBtn.recording {
            background-color: var(--danger-color);
            animation: pulse 1.2s infinite ease-in-out;
        }
        #micBtn.recording:hover {
            background-color: var(--danger-color-dark);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 hsla(0, 70%, 50%, 0.6); } 
            70% { box-shadow: 0 0 0 12px hsla(0, 70%, 50%, 0); }
            100% { box-shadow: 0 0 0 0 hsla(0, 70%, 50%, 0); }
        }

        .footer-copyright {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            font-size: 0.9em;
            color: var(--text-color-light);
        }

        /* Responsive adjustments */
        @media (max-width: 820px) { 
            .controls-row {
                flex-direction: column;
                align-items: stretch; 
            }
            .lang-select-group {
                width: 100%;
            }
            select, button {
                width: 100%; 
            }
            .history-favorites-section {
                grid-template-columns: 1fr; 
            }
        }
         @media (max-width: 480px) {
            body {
                padding: 15px;
            }
            .container {
                padding: 20px 15px;
            }
            h1 {
                font-size: 1.8em;
            }
            textarea {
                min-height: 120px;
                font-size: 0.95em;
            }
            .input-actions, .output-actions {
                flex-direction: column; 
            }
            .input-actions button, .output-actions button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1><i class="fas fa-language"></i> SA.Translator</h1>
         <p style="text-align: center; font-size: 0.9em; color: var(--secondary-color);">
            <strong>Important:</strong> For Microphone input to work,
            You will also need to grant microphone permissions when prompted.
        </p>

        <div class="controls-row">
            <div class="lang-select-group">
                <select id="sourceLang"></select>
                <span id="detectedLang" class="detected-lang-feedback"></span>
            </div>
            <button id="swapLanguagesBtn" title="Swap Languages"><i class="fas fa-exchange-alt"></i> Swap</button>
            <div class="lang-select-group">
                <select id="targetLang"></select>
            </div>
        </div>

        <div class="text-area-container">
            <textarea id="sourceText" placeholder="Enter text to translate..."></textarea>
            <div class="char-count" id="charCount">0 characters</div>
            <div class="input-actions">
                <button id="clearTextBtn" class="secondary" title="Clear Text"><i class="fas fa-times"></i> Clear</button>
                <button id="micBtn" title="Microphone Input"><i class="fas fa-microphone"></i> Speak</button>
                <input type="file" id="ocrFile" accept="image/png, image/jpeg" style="display: none;">
                <button id="ocrBtn" title="Translate Image (OCR)"><i class="fas fa-camera"></i> Image</button>
                <button id="handwritingBtn" class="secondary" title="Handwriting Input (Feature in development)"><i class="fas fa-pencil-alt"></i> Draw</button>
            </div>
        </div>

        <div class="text-area-container">
            <textarea id="translatedText" placeholder="Translation..." readonly></textarea>
             <div class="output-actions">
                <button id="copyTextBtn" title="Copy Translated Text"><i class="fas fa-copy"></i> Copy</button>
                <button id="ttsBtn" title="Speak Translated Text"><i class="fas fa-volume-up"></i> Speak</button>
                <button id="favoriteBtn" title="Add to Favorites"><i class="far fa-star"></i> Favorite</button>
            </div>
        </div>
        
        <div id="loadingFeedback" class="loading-feedback">
            <div class="spinner"></div>
            <span id="loadingMessage">Processing...</span>
        </div>

        <div class="history-favorites-section">
            <div class="history-column">
                <h3>
                    Recent Translations
                    <button id="clearAllHistoryBtn" class="secondary" title="Clear All History"><i class="fas fa-trash-alt"></i> Clear All</button>
                </h3>
                <div id="historyList"><p>No recent translations.</p></div>
            </div>
            <div class="favorites-column">
                <h3>
                    Favorite Translations
                    <button id="clearAllFavoritesBtn" class="secondary" title="Clear All Favorites"><i class="fas fa-trash-alt"></i> Clear All</button>
                </h3>
                <div id="favoritesList"><p>No favorite translations yet.</p></div>
            </div>
        </div>

        <div class="footer-copyright">
            © <span id="currentYear"></span> SA.Translator by Samir Alam. All Rights Reserved.
        </div>
    </div>

    <script>
        // SA.Translator - Main Application Logic
        // Coded by Samir Alam
        // Copyright © 2023-Present Samir Alam. All Rights Reserved.

        // IMPORTANT: For Microphone (Speech-to-Text) to work, this page MUST be served
        // over HTTPS or from localhost (e.g., using VS Code Live Server, or 'python -m http.server').
        // You will also need to grant microphone permissions to the site when prompted by your browser.

        document.addEventListener('DOMContentLoaded', () => {
            // ----- DOM Element References -----
            // Getting handles to all the interactive elements on the page.
            const sourceLangSelect = document.getElementById('sourceLang');
            const targetLangSelect = document.getElementById('targetLang');
            const sourceTextarea = document.getElementById('sourceText');
            const translatedTextarea = document.getElementById('translatedText');
            const swapLanguagesBtn = document.getElementById('swapLanguagesBtn');
            const clearTextBtn = document.getElementById('clearTextBtn');
            const copyTextBtn = document.getElementById('copyTextBtn');
            const charCountSpan = document.getElementById('charCount');
            const detectedLangSpan = document.getElementById('detectedLang');
            const micBtn = document.getElementById('micBtn');
            const ocrBtn = document.getElementById('ocrBtn');
            const ocrFileInput = document.getElementById('ocrFile');
            const handwritingBtn = document.getElementById('handwritingBtn');
            const favoriteBtn = document.getElementById('favoriteBtn');
            const ttsBtn = document.getElementById('ttsBtn');
            const historyListDiv = document.getElementById('historyList');
            const favoritesListDiv = document.getElementById('favoritesList');
            const clearAllHistoryBtn = document.getElementById('clearAllHistoryBtn');
            const clearAllFavoritesBtn = document.getElementById('clearAllFavoritesBtn');
            const loadingFeedbackDiv = document.getElementById('loadingFeedback');
            const loadingMessageSpan = document.getElementById('loadingMessage');
            const currentYearSpan = document.getElementById('currentYear');

            // Update copyright year
            if (currentYearSpan) {
                currentYearSpan.textContent = new Date().getFullYear();
            }

            // ----- Application Configuration & State -----
            const MYMEMORY_API_EMAIL = ""; // Optional: Your email for higher MyMemory API limits.

            // List of supported languages for translation, OCR, and Speech-to-Text.
            // Each object includes codes for different services.
            const languages = [
                { code: 'en', name: 'English', nativeName: 'English', tesseract: 'eng', speechLang: 'en-US' },
                { code: 'es', name: 'Spanish', nativeName: 'Español', tesseract: 'spa', speechLang: 'es-ES' },
                { code: 'fr', name: 'French', nativeName: 'Français', tesseract: 'fra', speechLang: 'fr-FR' },
                { code: 'de', name: 'German', nativeName: 'Deutsch', tesseract: 'deu', speechLang: 'de-DE' },
                { code: 'it', name: 'Italian', nativeName: 'Italiano', tesseract: 'ita', speechLang: 'it-IT' },
                { code: 'pt', name: 'Portuguese', nativeName: 'Português', tesseract: 'por', speechLang: 'pt-PT' }, 
                { code: 'nl', name: 'Dutch', nativeName: 'Nederlands', tesseract: 'nld', speechLang: 'nl-NL' },
                { code: 'ru', name: 'Russian', nativeName: 'Русский', tesseract: 'rus', speechLang: 'ru-RU' },
                { code: 'zh-CN', name: 'Chinese (Simplified)', nativeName: '中文 (简体)', tesseract: 'chi_sim', speechLang: 'zh-CN' },
                { code: 'ja', name: 'Japanese', nativeName: '日本語', tesseract: 'jpn', speechLang: 'ja-JP' },
                { code: 'ko', name: 'Korean', nativeName: '한국어', tesseract: 'kor', speechLang: 'ko-KR' },
                { code: 'ar', name: 'Arabic', nativeName: 'العربية', tesseract: 'ara', speechLang: 'ar-SA' }, 
                { code: 'he', name: 'Hebrew', nativeName: 'עברית', tesseract: 'heb', speechLang: 'he-IL' },
                { code: 'hi', name: 'Hindi', nativeName: 'हिन्दी', tesseract: 'hin', speechLang: 'hi-IN' },
                { code: 'mr', name: 'Marathi', nativeName: 'मराठी', tesseract: 'mar', speechLang: 'mr-IN' },
                { code: 'gu', name: 'Gujarati', nativeName: 'ગુજરાતી', tesseract: 'guj', speechLang: 'gu-IN' },
                { code: 'bn', name: 'Bengali', nativeName: 'বাংলা', tesseract: 'ben', speechLang: 'bn-IN' }, 
                { code: 'pa', name: 'Punjabi', nativeName: 'ਪੰਜਾਬੀ', tesseract: 'pan', speechLang: 'pa-IN' },
                { code: 'ta', name: 'Tamil', nativeName: 'தமிழ்', tesseract: 'tam', speechLang: 'ta-IN' },
                { code: 'te', name: 'Telugu', nativeName: 'తెలుగు', tesseract: 'tel', speechLang: 'te-IN' },
                { code: 'ml', name: 'Malayalam', nativeName: 'മലയാളം', tesseract: 'mal', speechLang: 'ml-IN' },
                { code: 'kn', name: 'Kannada', nativeName: 'ಕನ್ನಡ', tesseract: 'kan', speechLang: 'kn-IN' },
                { code: 'ur', name: 'Urdu', nativeName: 'اردو', tesseract: 'urd', speechLang: 'ur-IN' }, 
                { code: 'id', name: 'Indonesian', nativeName: 'Bahasa Indonesia', tesseract: 'ind', speechLang: 'id-ID' },
                { code: 'ms', name: 'Malaysian', nativeName: 'Bahasa Melayu', tesseract: 'msa', speechLang: 'ms-MY' },
                { code: 'th', name: 'Thai', nativeName: 'ไทย', tesseract: 'tha', speechLang: 'th-TH' },
                { code: 'vi', name: 'Vietnamese', nativeName: 'Tiếng Việt', tesseract: 'vie', speechLang: 'vi-VN' },
                { code: 'pl', name: 'Polish', nativeName: 'Polski', tesseract: 'pol', speechLang: 'pl-PL' },
                { code: 'cs', name: 'Czech', nativeName: 'Čeština', tesseract: 'ces', speechLang: 'cs-CZ' },
                { code: 'hu', name: 'Hungarian', nativeName: 'Magyar', tesseract: 'hun', speechLang: 'hu-HU' },
                { code: 'fi', name: 'Finnish', nativeName: 'Suomi', tesseract: 'fin', speechLang: 'fi-FI' },
            ];
            
            // Helper map for Tesseract language codes.
            const tesseractLangMap = languages.reduce((acc, lang) => {
                acc[lang.code] = lang.tesseract;
                return acc;
            }, {});

            // Application state variables
            let translationHistory = JSON.parse(localStorage.getItem('saTranslatorHistory')) || []; // Renamed localStorage key
            let favorites = JSON.parse(localStorage.getItem('saTranslatorFavorites')) || []; // Renamed localStorage key
            let debounceTimer; // For debouncing API calls on text input.

            // ----- UI Helper Functions -----
            // Shows a loading indicator with a message.
            function showLoading(message = "Processing...") {
                loadingMessageSpan.textContent = message;
                loadingFeedbackDiv.classList.add('active');
            }

            // Hides the loading indicator.
            function hideLoading() {
                loadingFeedbackDiv.classList.remove('active');
            }

            // ----- Core Functionality -----

            // Populates the language selection dropdowns.
            function populateLanguageDropdowns() {
                const autoDetectOption = document.createElement('option');
                autoDetectOption.value = 'auto';
                autoDetectOption.textContent = 'Auto-detect Language';
                sourceLangSelect.appendChild(autoDetectOption);

                languages.forEach(lang => {
                    const optionSource = document.createElement('option');
                    optionSource.value = lang.code;
                    optionSource.textContent = `${lang.nativeName} (${lang.name})`;
                    sourceLangSelect.appendChild(optionSource);

                    const optionTarget = document.createElement('option');
                    optionTarget.value = lang.code;
                    optionTarget.textContent = `${lang.nativeName} (${lang.name})`;
                    targetLangSelect.appendChild(optionTarget);
                });
                sourceLangSelect.value = 'auto'; // Default source
                const defaultTargetLang = 'es'; // Default target to Spanish
                if (languages.some(lang => lang.code === defaultTargetLang)) {
                    targetLangSelect.value = defaultTargetLang;
                } else if (languages.length > 0) {
                    targetLangSelect.value = languages[0].code; // Fallback
                }
            }

            // Handles the actual translation via MyMemory API.
            async function performTranslation() {
                const sourceText = sourceTextarea.value.trim();
                const sourceLang = sourceLangSelect.value;
                const targetLang = targetLangSelect.value;

                detectedLangSpan.textContent = ''; // Clear previous detection

                // If no text, clear translation and update favorite state
                if (!sourceText) {
                    translatedTextarea.value = '';
                    updateFavoriteButtonState(); 
                    return;
                }
                
                // If source and target languages are the same (and not auto-detect), just copy text
                if (sourceLang === targetLang && sourceLang !== 'auto') {
                    translatedTextarea.value = sourceText;
                    updateFavoriteButtonState();
                    return;
                }

                showLoading("Translating, please wait...");
                
                try {
                    // Construct language pair for MyMemory API
                    let langPair = `${sourceLang === 'auto' ? '' : sourceLang}|${targetLang}`;
                     if (sourceLang === 'auto') { 
                        langPair = `|${targetLang}`; // MyMemory auto-detects if source is empty in pair
                    }
                    
                    let apiUrl = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(sourceText)}&langpair=${langPair}`;
                    if (MYMEMORY_API_EMAIL) {
                        apiUrl += `&de=${MYMEMORY_API_EMAIL}`; // Add email for potentially higher limits
                    }
                    
                    const response = await fetch(apiUrl);
                    if (!response.ok) { // Check for network errors
                        throw new Error(`API Network Error: ${response.statusText} (Status: ${response.status})`);
                    }
                    const data = await response.json();

                    // Process API response
                    if (data.responseData && data.responseData.translatedText) {
                        translatedTextarea.value = data.responseData.translatedText;
                        let detectedSourceLangActual = sourceLang; // Actual source language used

                        // If auto-detect was on, show the detected language
                        if (sourceLang === 'auto' && data.responseData.detectedLanguage) {
                            const detected = languages.find(l => l.code.toLowerCase().startsWith(data.responseData.detectedLanguage.toLowerCase()));
                            if (detected) {
                                detectedLangSpan.textContent = `Detected: ${detected.name}`;
                                detectedSourceLangActual = detected.code;
                            } else {
                                // Fallback if detected language code isn't in our known list
                                detectedLangSpan.textContent = `Detected: ${data.responseData.detectedLanguage.toUpperCase()}`;
                                detectedSourceLangActual = data.responseData.detectedLanguage;
                            }
                        }
                        // Add to history and update favorite button state
                        addTranslationToHistory(sourceText, data.responseData.translatedText, sourceLang, targetLang, detectedSourceLangActual);
                        updateFavoriteButtonState();
                    } else if (data.responseStatus === 403) { // MyMemory specific for rate limits/blocks
                         throw new Error(data.responseDetails || 'Translation API request limit reached or IP blocked. Please try again later.');
                    }
                    else { // Other API errors
                        throw new Error(data.responseDetails || 'Translation failed or no text was returned by the API.');
                    }
                } catch (error) { // Catch all errors (network, API, parsing)
                    console.error('Translation error caught:', error);
                    translatedTextarea.value = 'Error: Could not translate text.';
                    alert(`Translation Error: ${error.message}\n\nPlease check your input or try again later.`);
                } finally {
                    hideLoading(); // Always hide loading indicator
                }
            }

            // ----- Event Listeners Setup -----

            // Translate text as user types (debounced for performance).
            sourceTextarea.addEventListener('input', () => {
                charCountSpan.textContent = `${sourceTextarea.value.length} characters`;
                clearTimeout(debounceTimer); // Clear previous timer
                // Set a new timer to call translation after a short delay
                debounceTimer = setTimeout(performTranslation, 700); 
            });

            // Re-translate when language selections change.
            [sourceLangSelect, targetLangSelect].forEach(select => {
                select.addEventListener('change', performTranslation);
            });

            // Swap source and target languages and text.
            swapLanguagesBtn.addEventListener('click', () => {
                const currentSourceLang = sourceLangSelect.value;
                const currentTargetLang = targetLangSelect.value;
                const currentSourceText = sourceTextarea.value;
                const currentTranslatedText = translatedTextarea.value;

                // Logic to handle 'auto' when swapping
                if (currentSourceLang === 'auto') {
                    const detectedLangCode = languages.find(l => detectedLangSpan.textContent.includes(l.name))?.code;
                    if (detectedLangCode && languages.some(l => l.code === detectedLangCode)) {
                         targetLangSelect.value = detectedLangCode; // New target is detected language
                    } else {
                        targetLangSelect.value = currentTargetLang; // Keep current target if no clear detection
                    }
                } else {
                    targetLangSelect.value = currentSourceLang; // New target is old source
                }

                // Ensure new source language is valid
                if(languages.some(l => l.code === currentTargetLang)){ 
                    sourceLangSelect.value = currentTargetLang; // New source is old target
                } else { 
                    sourceLangSelect.value = 'auto'; // Default to auto if old target was not a selectable source
                }

                sourceTextarea.value = currentTranslatedText; // New source text is old translated text

                // Re-translate if there's text in the new source
                if (sourceTextarea.value) {
                    performTranslation();
                } else {
                    translatedTextarea.value = ''; // Clear translation if new source is empty
                    detectedLangSpan.textContent = '';
                }
                charCountSpan.textContent = `${sourceTextarea.value.length} characters`;
                updateFavoriteButtonState();
            });

            // Clear input and output text areas.
            clearTextBtn.addEventListener('click', () => {
                sourceTextarea.value = '';
                translatedTextarea.value = '';
                charCountSpan.textContent = '0 characters';
                detectedLangSpan.textContent = '';
                updateFavoriteButtonState();
            });

            // Copy translated text to clipboard.
            copyTextBtn.addEventListener('click', () => {
                if(translatedTextarea.value && !translatedTextarea.value.startsWith('Error:')) {
                    navigator.clipboard.writeText(translatedTextarea.value)
                        .then(() => {
                            const originalText = copyTextBtn.innerHTML;
                            copyTextBtn.innerHTML = '<i class="fas fa-check"></i> Copied!'; // Visual feedback
                            setTimeout(() => copyTextBtn.innerHTML = originalText, 2000); // Revert after 2s
                        })
                        .catch(err => {
                            console.error('Failed to copy text to clipboard:', err);
                            alert('Failed to copy text. Your browser might not support this feature or permissions are denied.');
                        });
                } else if (translatedTextarea.value.startsWith('Error:')) {
                    alert("Cannot copy an error message.");
                }
            });
            
            // ----- Translation History Management -----
            // Adds a translation entry to history and saves to LocalStorage.
            function addTranslationToHistory(sourceText, translatedText, sourceLangSetting, targetLang, detectedSourceLangActual) {
                // Determine the final source language (especially if 'auto' was used)
                const finalSourceLang = sourceLangSetting === 'auto' 
                    ? (languages.find(l=>l.code.toLowerCase().startsWith(detectedSourceLangActual.toLowerCase()))?.code || detectedSourceLangActual) 
                    : sourceLangSetting;

                const entry = { sourceText, translatedText, sourceLang: finalSourceLang, targetLang, timestamp: new Date().toISOString() };
                translationHistory.unshift(entry); // Add to the beginning of the array
                if (translationHistory.length > 20) { // Keep history to a max of 20 items
                    translationHistory.pop(); // Remove the oldest item
                }
                localStorage.setItem('saTranslatorHistory', JSON.stringify(translationHistory)); // Save to localStorage
                renderTranslationHistory(); // Update the UI
            }

            // Renders the translation history list in the UI.
            function renderTranslationHistory() {
                historyListDiv.innerHTML = ''; // Clear existing list
                if (translationHistory.length === 0) {
                    historyListDiv.innerHTML = '<p>No recent translations yet.</p>';
                    return;
                }
                translationHistory.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'history-item';
                    // Find language names for display
                    const sourceLangName = languages.find(l=>l.code === item.sourceLang)?.name || item.sourceLang.toUpperCase();
                    const targetLangName = languages.find(l=>l.code === item.targetLang)?.name || item.targetLang.toUpperCase();
                    // Truncate long texts for display
                    const shortSource = item.sourceText.length > 50 ? item.sourceText.substring(0,47) + '...' : item.sourceText;
                    const shortTranslated = item.translatedText.length > 50 ? item.translatedText.substring(0,47) + '...' : item.translatedText;

                    div.innerHTML = `
                        <p title="${item.sourceText}"><strong>From (${sourceLangName}):</strong> ${shortSource}</p>
                        <p title="${item.translatedText}"><strong>To (${targetLangName}):</strong> ${shortTranslated}</p>
                        <p class="meta">${new Date(item.timestamp).toLocaleString()}</p>
                        <div class="actions">
                            <button class="delete-history-item" data-index="${index}" title="Delete this history item"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    `;
                    // Event listener to repopulate fields when a history item is clicked
                    div.addEventListener('click', (e) => {
                        if (e.target.closest('.delete-history-item')) return; // Don't repopulate if delete button was clicked
                        sourceTextarea.value = item.sourceText;
                        translatedTextarea.value = item.translatedText;
                        sourceLangSelect.value = item.sourceLang; // Set specific language, not 'auto'
                        targetLangSelect.value = item.targetLang;
                        charCountSpan.textContent = `${item.sourceText.length} characters`;
                        detectedLangSpan.textContent = ''; // Clear detection message
                        updateFavoriteButtonState();
                        sourceTextarea.focus(); // Focus on input area for convenience
                    });
                    historyListDiv.appendChild(div);
                });

                // Add event listeners to all delete buttons in the history
                document.querySelectorAll('.delete-history-item').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent the parent div's click event
                        const index = parseInt(e.currentTarget.dataset.index);
                        clearSingleHistoryItem(index);
                    });
                });
            }
            
            // Removes a single item from history.
            function clearSingleHistoryItem(index) {
                translationHistory.splice(index, 1); // Remove item from array
                localStorage.setItem('saTranslatorHistory', JSON.stringify(translationHistory));
                renderTranslationHistory(); // Re-render the list
            }

            // Clears all translation history.
            clearAllHistoryBtn.addEventListener('click', () => {
                if (confirm("Are you sure you want to clear ALL translation history? This cannot be undone.")) {
                    translationHistory = [];
                    localStorage.removeItem('saTranslatorHistory');
                    renderTranslationHistory();
                }
            });

            // ----- Favorites Management -----
            // Checks if the current translation is already in favorites.
            function isCurrentTranslationFavorited() {
                const sourceText = sourceTextarea.value.trim();
                const translatedText = translatedTextarea.value.trim(); 
                if (!sourceText || !translatedText) return false; // Can't favorite if empty

                const sourceLang = sourceLangSelect.value;
                const targetLang = targetLangSelect.value;
                return favorites.some(fav => 
                    fav.sourceText === sourceText &&
                    fav.translatedText === translatedText &&
                    fav.sourceLang === sourceLang && // Use the selected source, not necessarily detected
                    fav.targetLang === targetLang
                );
            }

            // Updates the appearance and state of the favorite button.
            function updateFavoriteButtonState() {
                const canFavorite = sourceTextarea.value.trim() && 
                                    translatedTextarea.value.trim() && 
                                    !translatedTextarea.value.startsWith('Error:');
                favoriteBtn.disabled = !canFavorite;

                if (canFavorite && isCurrentTranslationFavorited()) {
                    favoriteBtn.innerHTML = '<i class="fas fa-star"></i> Favorited';
                    favoriteBtn.classList.add('secondary'); 
                } else {
                    favoriteBtn.innerHTML = '<i class="far fa-star"></i> Favorite';
                    favoriteBtn.classList.remove('secondary');
                }
            }

            // Toggles a translation's favorite status.
            favoriteBtn.addEventListener('click', () => {
                const sourceText = sourceTextarea.value.trim();
                const translatedText = translatedTextarea.value.trim();
                const sourceLang = sourceLangSelect.value; // Use the selected source lang for consistency
                const targetLang = targetLangSelect.value;

                // Don't favorite if there's no valid text or it's an error
                if (!sourceText || !translatedText || translatedText.startsWith('Error:')) return;

                if (isCurrentTranslationFavorited()) {
                    // Remove from favorites
                    favorites = favorites.filter(fav => 
                        !(fav.sourceText === sourceText &&
                        fav.translatedText === translatedText &&
                        fav.sourceLang === sourceLang &&
                        fav.targetLang === targetLang)
                    );
                } else {
                    // Add to favorites
                    favorites.unshift({ sourceText, translatedText, sourceLang, targetLang, timestamp: new Date().toISOString() });
                }
                localStorage.setItem('saTranslatorFavorites', JSON.stringify(favorites)); // Save to localStorage
                renderFavoritesList();
                updateFavoriteButtonState();
            });

            // Renders the list of favorite translations.
            function renderFavoritesList() {
                favoritesListDiv.innerHTML = ''; // Clear current list
                 if (favorites.length === 0) {
                    favoritesListDiv.innerHTML = '<p>No favorite translations saved yet.</p>';
                    return;
                }
                favorites.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'favorite-item';
                    const sourceLangName = languages.find(l=>l.code === item.sourceLang)?.name || item.sourceLang.toUpperCase();
                    const targetLangName = languages.find(l=>l.code === item.targetLang)?.name || item.targetLang.toUpperCase();
                    const shortSource = item.sourceText.length > 50 ? item.sourceText.substring(0,47) + '...' : item.sourceText;
                    const shortTranslated = item.translatedText.length > 50 ? item.translatedText.substring(0,47) + '...' : item.translatedText;

                    div.innerHTML = `
                        <p title="${item.sourceText}"><strong>From (${sourceLangName}):</strong> ${shortSource}</p>
                        <p title="${item.translatedText}"><strong>To (${targetLangName}):</strong> ${shortTranslated}</p>
                        <p class="meta">Saved: ${new Date(item.timestamp).toLocaleString()}</p>
                        <div class="actions">
                             <button class="delete-favorite-item" data-index="${index}" title="Remove this favorite"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    `;
                     // Event listener to repopulate fields from a favorite item
                     div.addEventListener('click', (e) => {
                        if (e.target.closest('.delete-favorite-item')) return; // Don't repopulate if delete was clicked
                        sourceTextarea.value = item.sourceText;
                        translatedTextarea.value = item.translatedText;
                        sourceLangSelect.value = item.sourceLang;
                        targetLangSelect.value = item.targetLang;
                        charCountSpan.textContent = `${item.sourceText.length} characters`;
                        detectedLangSpan.textContent = ''; // Clear detection
                        updateFavoriteButtonState();
                        sourceTextarea.focus();
                    });
                    favoritesListDiv.appendChild(div);
                });

                // Add event listeners to all delete buttons for favorites
                document.querySelectorAll('.delete-favorite-item').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent parent click
                        const index = parseInt(e.currentTarget.dataset.index);
                        removeSingleFavoriteItem(index);
                    });
                });
            }
            
            // Removes a single item from favorites.
            function removeSingleFavoriteItem(index) {
                favorites.splice(index, 1);
                localStorage.setItem('saTranslatorFavorites', JSON.stringify(favorites));
                renderFavoritesList();
                updateFavoriteButtonState(); // Update button if current translation was removed
            }

            // Clears all favorite translations.
            clearAllFavoritesBtn.addEventListener('click', () => {
                 if (confirm("Are you sure you want to clear ALL favorite translations? This action cannot be undone.")) {
                    favorites = [];
                    localStorage.removeItem('saTranslatorFavorites');
                    renderFavoritesList();
                    updateFavoriteButtonState();
                }
            });
            
            // Copyright © 2023-Present Samir Alam. All Rights Reserved.
            // The following code is part of SA.Translator.

            // ----- Speech-to-Text (STT) via Web Speech API -----
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition; // Will hold the SpeechRecognition instance

            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = false; // Stop after first pause in speech
                recognition.interimResults = false; // We only want final, confirmed results

                // Called when speech recognition starts.
                recognition.onstart = () => {
                    micBtn.classList.add('recording');
                    micBtn.innerHTML = '<i class="fas fa-stop-circle"></i> Stop Listening';
                    showLoading("Listening... Please speak clearly.");
                };

                // Called when a result is received.
                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    sourceTextarea.value = transcript; // Populate source text area
                    charCountSpan.textContent = `${transcript.length} characters`;
                    performTranslation(); // Trigger translation of the spoken text
                };

                // Called when an error occurs.
                recognition.onerror = (event) => {
                    console.error('Speech recognition error event:', event); 
                    let errorMessage = `Speech recognition error: ${event.error}.`;
                    // Provide more user-friendly error messages for common issues
                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        errorMessage = "Microphone access denied or service not allowed. \nPlease ensure you are on a secure (HTTPS) connection or localhost, and check microphone permissions for this site in your browser settings. You might need to grant permission explicitly.";
                    } else if (event.error === 'no-speech') {
                        errorMessage = "No speech was detected. Please try speaking clearly into your microphone.";
                    } else if (event.error === 'audio-capture') {
                        errorMessage = "Microphone not found or problem with audio capture. Ensure your microphone is properly connected, configured, and not muted.";
                    } else if (event.error === 'network') {
                        errorMessage = "A network error occurred during speech recognition. Please check your internet connection.";
                    } else if (event.error === 'language-not-supported'){
                        errorMessage = `The selected language (${recognition.lang}) is not supported for speech input by your browser. Try a different language or 'Auto-detect'.`;
                    }
                    alert(errorMessage);
                    // Reset UI elements
                    micBtn.classList.remove('recording'); 
                    micBtn.innerHTML = '<i class="fas fa-microphone"></i> Speak';
                    hideLoading();
                };

                // Called when speech recognition ends (either naturally or by .stop()).
                recognition.onend = () => {
                    // Ensure UI is reset if recognition stops for any reason.
                    if (micBtn.classList.contains('recording')) { 
                        micBtn.classList.remove('recording');
                        micBtn.innerHTML = '<i class="fas fa-microphone"></i> Speak';
                        hideLoading();
                    }
                };

                // Event listener for the microphone button.
                micBtn.addEventListener('click', () => {
                    if (!navigator.onLine) { // Check for internet connection, as STT is usually cloud-based
                        alert("You appear to be offline. Speech recognition requires an internet connection.");
                        return;
                    }
                    if (micBtn.classList.contains('recording')) { // If already recording, stop it
                        recognition.stop();
                    } else { // Otherwise, start recording
                        try {
                            let selectedLangCode = sourceLangSelect.value;
                            let speechLangToUse;

                            // Determine the language to use for speech recognition
                            if (selectedLangCode === 'auto') {
                                speechLangToUse = navigator.language || 'en-US'; // Default to browser's language or US English
                                console.log("STT: 'auto' selected, using browser/default language:", speechLangToUse);
                            } else {
                                const langObj = languages.find(l => l.code === selectedLangCode);
                                speechLangToUse = langObj?.speechLang || selectedLangCode; // Use specific speechLang if available
                                console.log("STT: Specific language selected:", selectedLangCode, "-> Using speechLang:", speechLangToUse);
                            }
                            
                            recognition.lang = speechLangToUse; // Set the language for recognition
                            recognition.start(); // Start the recognition process
                        } catch (err) { // Catch errors during start attempt
                            console.error("Error attempting to start speech recognition:", err);
                            alert("Could not start speech recognition. \nError: " + err.message + "\n\nCommon issues:\n- Ensure you are on a secure (HTTPS) connection or localhost.\n- Check microphone permissions for this site in your browser settings.\n- The selected language might not be supported for speech input by your browser.");
                            // Reset UI on error
                            micBtn.classList.remove('recording');
                            micBtn.innerHTML = '<i class="fas fa-microphone"></i> Speak';
                            hideLoading();
                        }
                    }
                });

            } else { // If SpeechRecognition API is not supported by the browser
                micBtn.disabled = true;
                micBtn.title = "Speech recognition not supported by your browser.";
                console.warn("Web SpeechRecognition API is not supported in this browser.");
                alert("Sorry, speech recognition is not supported by your browser. Please try using a modern browser like Chrome or Edge.");
            }

            // ----- Optical Character Recognition (OCR) via Tesseract.js -----
            ocrBtn.addEventListener('click', () => ocrFileInput.click()); // Trigger hidden file input
            ocrFileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return; // No file selected

                // Validate file type and size
                if (!['image/jpeg', 'image/png'].includes(file.type)) {
                    alert('Invalid file type. Please upload a JPEG or PNG image.');
                    return;
                }
                if (file.size > 5 * 1024 * 1024) { // 5MB limit
                    alert('File is too large. Maximum allowed size is 5MB.');
                    return;
                }

                showLoading("Preparing image for OCR...");
                try {
                    let ocrLangCode = 'eng'; // Default to English for OCR
                    const selectedSourceLangCode = sourceLangSelect.value;
                    
                    // Determine which Tesseract language model to use
                    if (selectedSourceLangCode !== 'auto' && tesseractLangMap[selectedSourceLangCode]) {
                        ocrLangCode = tesseractLangMap[selectedSourceLangCode];
                    } else if (selectedSourceLangCode !== 'auto') {
                        // If selected language doesn't have a Tesseract mapping, warn and use English
                        console.warn(`Tesseract language code not found for ${selectedSourceLangCode}. Defaulting to English for OCR.`);
                        const langName = languages.find(l=>l.code === selectedSourceLangCode)?.name || selectedSourceLangCode;
                        alert(`OCR for '${langName}' is not available with the current setup. Text will be recognized as English.`);
                    }
                    
                    // Create Tesseract worker with progress logging
                    const worker = await Tesseract.createWorker(ocrLangCode, 1, {
                         logger: m => { // Log progress messages from Tesseract
                            if (m.status === 'recognizing text') {
                                showLoading(`Recognizing text: ${Math.round(m.progress * 100)}%`);
                            } else if (m.status === 'loading language model') {
                                showLoading(`Loading OCR model for ${ocrLangCode.toUpperCase()}... This may take a moment.`);
                            }
                         }
                    });
                    
                    const { data: { text } } = await worker.recognize(file); // Perform OCR
                    sourceTextarea.value = text; // Populate source text area
                    charCountSpan.textContent = `${text.length} characters`;
                    await worker.terminate(); // Terminate worker to free resources
                    performTranslation(); // Translate the extracted text
                } catch (error) { // Handle OCR errors
                    console.error('OCR Error:', error);
                    alert('Failed to extract text from the image. The image might be unclear, the language unsupported, or an OCR processing error occurred. Please check the console for more details.');
                } finally {
                    hideLoading(); // Always hide loading
                    ocrFileInput.value = ''; // Reset file input for next use
                }
            });
            
            // ----- Handwriting Input (Placeholder) -----
            handwritingBtn.addEventListener('click', () => {
                alert("Handwriting input is a complex feature planned for future development. It is not yet functional in this demo version of SA.Translator.");
            });

            // ----- Text-to-Speech (TTS) via Web Speech API -----
            const speechSynthesis = window.speechSynthesis;
            let availableVoices = []; // To store available TTS voices

            if (speechSynthesis) {
                // Function to load available voices (can be asynchronous)
                function loadVoices() {
                    availableVoices = speechSynthesis.getVoices();
                     if (availableVoices.length > 0 && ttsBtn.title === "Loading voices...") {
                        ttsBtn.title = "Speak Translated Text"; // Update tooltip
                        ttsBtn.disabled = false; // Enable button
                    }
                }
                loadVoices(); // Initial attempt to load
                // Event listener for when voices change (e.g., loaded asynchronously)
                if (speechSynthesis.onvoiceschanged !== undefined) {
                    speechSynthesis.onvoiceschanged = loadVoices;
                }
                 // If voices not immediately available, disable button temporarily
                 if (availableVoices.length === 0) { 
                    ttsBtn.title = "Loading voices...";
                    ttsBtn.disabled = true;
                }

                // Event listener for the TTS button
                ttsBtn.addEventListener('click', () => {
                    if (availableVoices.length === 0) { // Try loading voices again if they weren't ready
                        loadVoices(); 
                        if (availableVoices.length === 0) { // Still not ready
                           alert("TTS voices are not available yet. Please try again in a moment.");
                           return;
                        }
                    }

                    const textToSpeak = translatedTextarea.value.trim();
                    // Don't speak if no text or if it's an error message
                    if (!textToSpeak || textToSpeak.startsWith('Error:')) {
                        alert("Nothing valid to speak at the moment.");
                        return;
                    }
                    
                    // If already speaking, cancel current speech
                    if (speechSynthesis.speaking) {
                        speechSynthesis.cancel(); 
                        return; 
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(textToSpeak);
                    const targetLangCode = targetLangSelect.value;
                    const langObj = languages.find(l => l.code === targetLangCode);
                    let voiceLangToUse = langObj?.speechLang || targetLangCode; // Prefer specific BCP 47 speechLang

                    // Try to find the best matching voice for the target language
                    let bestVoice = availableVoices.find(voice => voice.lang === voiceLangToUse);
                    if (!bestVoice) { // If exact match fails, try matching primary language part (e.g., 'en' from 'en-US')
                        bestVoice = availableVoices.find(voice => voice.lang.startsWith(voiceLangToUse.split('-')[0]));
                    }
                    if (bestVoice) { // If a good voice is found, use it
                        utterance.voice = bestVoice;
                        console.log("TTS using voice:", bestVoice.name, "for lang:", bestVoice.lang);
                    } else { // Otherwise, set lang on utterance and let browser pick default
                        utterance.lang = voiceLangToUse; 
                        console.warn(`No specific voice found for language code '${voiceLangToUse}'. Using browser default for this language if available.`);
                    }
                    
                    // Event handlers for the utterance
                    utterance.onstart = () => ttsBtn.innerHTML = '<i class="fas fa-stop-circle"></i> Stop Speaking';
                    utterance.onend = () => ttsBtn.innerHTML = '<i class="fas fa-volume-up"></i> Speak';
                    utterance.onerror = (e) => {
                        console.error("Speech synthesis error event:", e);
                        alert(`Could not speak the text: ${e.error}. Your browser might not support this language or voice for speech output.`);
                        ttsBtn.innerHTML = '<i class="fas fa-volume-up"></i> Speak'; // Reset button
                    };

                    speechSynthesis.speak(utterance); // Speak the text
                });
            } else { // If SpeechSynthesis API is not supported
                ttsBtn.disabled = true;
                ttsBtn.title = "Text-to-speech not supported by your browser.";
                console.warn("Web SpeechSynthesis API is not supported in this browser.");
            }

            // ----- Initial Application Setup -----
            // This runs once the DOM is fully loaded.
            function initializeApp() {
                console.log("SA.Translator Initializing...");
                populateLanguageDropdowns();
                renderTranslationHistory();
                renderFavoritesList();
                updateFavoriteButtonState(); 
                console.log("SA.Translator Ready.");
            }

            initializeApp(); // Call the initialization function.

        }); // End of DOMContentLoaded
    </script>
</body>
</html>